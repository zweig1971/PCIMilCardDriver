//////////////////////////////////////////////////////////////////////
// File - mydriver_lib.h
//
// Library for accessing the MYDRIVER card,
// Code was generated by Driver Wizard.
// It accesses the hardware via WinDriver functions.
// 
//////////////////////////////////////////////////////////////////////

#ifndef _MYDRIVER_LIB_H_
#define _MYDRIVER_LIB_H_

#include "windrvr.h"
#include "pci_regs.h"
#include "bits.h"


#ifdef __cplusplus
extern "C" {
#endif

enum { MYDRIVER_DEFAULT_VENDOR_ID = 0x10B5 };
enum { MYDRIVER_DEFAULT_DEVICE_ID = 0x9050 };

enum
{
    MYDRIVER_MODE_BYTE   = 0,
    MYDRIVER_MODE_WORD   = 1,
    MYDRIVER_MODE_DWORD  = 2
};
typedef DWORD MYDRIVER_MODE;

enum
{
    MYDRIVER_AD_BAR0 = AD_PCI_BAR0,
    MYDRIVER_AD_BAR1 = AD_PCI_BAR1,
    MYDRIVER_AD_BAR2 = AD_PCI_BAR2,
    MYDRIVER_AD_BAR3 = AD_PCI_BAR3,
    MYDRIVER_AD_BAR4 = AD_PCI_BAR4,
    MYDRIVER_AD_BAR5 = AD_PCI_BAR5,
    MYDRIVER_AD_EPROM = AD_PCI_BAR_EPROM,
};
typedef DWORD MYDRIVER_ADDR;

// Number of IO and memory ranges
enum { MYDRIVER_ITEMS = AD_PCI_BARS };

// MYDRIVER register definitions 
enum { MYDRIVER_Mil_cmd_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Mil_cmd_OFFSET = 0x8 };
enum { MYDRIVER_Mil_write_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Mil_write_OFFSET = 0x4 };
enum { MYDRIVER_Reset_Card_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Reset_Card_OFFSET = 0xc };
enum { MYDRIVER_Mil_read_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Mil_read_OFFSET = 0x4 };
enum { MYDRIVER_Set_Timer2_10us_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Set_Timer2_10us_OFFSET = 0x14 };
enum { MYDRIVER_Set_Timer1_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Set_Timer1_OFFSET = 0x10 };
enum { MYDRIVER_Set_Timer2_1ms_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Set_Timer2_1ms_OFFSET = 0x18 };
enum { MYDRIVER_Mil_Status_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Mil_Status_OFFSET = 0x0 };
enum { MYDRIVER_C_Filter_ADR_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_C_Filter_ADR_OFFSET = 0x4000};
enum { MYDRIVER_ControlRegister1_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_ControlRegister1_OFFSET = 0x1c };
enum { MYDRIVER_Slave_Mil_interlog_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Slave_Mil_interlog_OFFSET = 0x20 };
enum { MYDRIVER_EV_Time_Rd_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_EV_Time_Rd_OFFSET = 0x28 };
enum { MYDRIVER_Event_Read_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Event_Read_OFFSET = 0x24 };
enum { MYDRIVER_Intrrrupt_Mask_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Intrrrupt_Mask_OFFSET = 0x2c };
enum { MYDRIVER_Aux_IO_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Aux_IO_OFFSET = 0x30 };
enum { MYDRIVER_INTCSR_SPACE = MYDRIVER_AD_BAR0 };
enum { MYDRIVER_INTCSR_OFFSET = 0x4c };
enum { MYDRIVER_ControlReg_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_ControlReg_OFFSET = 0x1c };
enum { MYDRIVER_Puls1_Start_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls1_Start_Soft_OFFSET = 0x34 };
enum { MYDRIVER_Puls1_Stop_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls1_Stop_Soft_OFFSET = 0x38 };
enum { MYDRIVER_Puls2_Start_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls2_Start_Soft_OFFSET = 0x3c };
enum { MYDRIVER_Puls2_Stop_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls2_Stop_Soft_OFFSET = 0x40 };
enum { MYDRIVER_Puls3_Start_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls3_Start_Soft_OFFSET = 0x44 };
enum { MYDRIVER_Puls3_Stop_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls3_Stop_Soft_OFFSET = 0x48 };
enum { MYDRIVER_Puls4_Start_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls4_Start_Soft_OFFSET = 0x4C };
enum { MYDRIVER_Puls4_Stop_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls4_Stop_Soft_OFFSET = 0x50 };
enum { MYDRIVER_Puls5_Start_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls5_Start_Soft_OFFSET = 0x54 };
enum { MYDRIVER_Puls5_Stop_Soft_SPACE = MYDRIVER_AD_BAR2 };
enum { MYDRIVER_Puls5_Stop_Soft_OFFSET = 0x58 };

typedef struct MYDRIVER_STRUCT *MYDRIVER_HANDLE;

typedef struct
{
    DWORD dwCounter;   // number of interrupts received
    DWORD dwLost;      // number of interrupts not yet dealt with
    BOOL fStopped;     // was interrupt disabled during wait
} MYDRIVER_INT_RESULT;

// Interrupt aufruf- funktionen
typedef void (*MYDRIVER_INT_HANDLER)(PVOID pUserDat);

// options for MYDRIVER_Open
enum { MYDRIVER_OPEN_USE_INT =   0x1 };

BOOL MYDRIVER_Open (MYDRIVER_HANDLE *phMYDRIVER, DWORD dwVendorID, DWORD dwDeviceID, DWORD nCardNum, DWORD dwOptions, DWORD *UserStatus);
void MYDRIVER_RegisterWinDriver();
void MYDRIVER_Close(MYDRIVER_HANDLE hMYDRIVER);
DWORD MYDRIVER_CountCards (DWORD dwVendorID, DWORD dwDeviceID, int* status);
BOOL MYDRIVER_IsAddrSpaceActive(MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace);

void MYDRIVER_GetPciSlot(MYDRIVER_HANDLE hMYDRIVER, WD_PCI_SLOT *pPciSlot);

// General read/write function
void MYDRIVER_ReadWriteBlock(MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset, BOOL fRead, PVOID buf, DWORD dwBytes, MYDRIVER_MODE mode);
BYTE MYDRIVER_ReadByte (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset);
WORD MYDRIVER_ReadWord (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset);
DWORD MYDRIVER_ReadDword (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset);
void MYDRIVER_WriteByte (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset, BYTE data);
void MYDRIVER_WriteWord (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset, WORD data);
void MYDRIVER_WriteDword (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_ADDR addrSpace, DWORD dwOffset, DWORD data);
void MYDRIVER_WriteMil_cmd (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WriteMil_write (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WriteReset_Card (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
DWORD MYDRIVER_ReadMil_read (MYDRIVER_HANDLE hMYDRIVER);
void MYDRIVER_WriteSet_Timer2 (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WriteSet_Timer1 (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WriteSet_Timer2_base (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
DWORD MYDRIVER_Read_C_Filter_ADR (MYDRIVER_HANDLE hMYDRIVER, DWORD OffsetValue);
void MYDRIVER_Write_C_Filter_ADR (MYDRIVER_HANDLE hMYDRIVER, DWORD data, DWORD OffsetValue);
DWORD MYDRIVER_ReadMil_Status (MYDRIVER_HANDLE hMYDRIVER);
void MYDRIVER_WriteControlRegister1(MYDRIVER_HANDLE hMYDRIVER, DWORD data);
DWORD MYDRIVER_ReadControlRegister1(MYDRIVER_HANDLE hMYDRIVER);
void MYDRIVER_WriteSlave_Mil_interlog (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
DWORD MYDRIVER_ReadEV_Time_Rd (MYDRIVER_HANDLE hMYDRIVER);
DWORD MYDRIVER_ReadEvent_Read (MYDRIVER_HANDLE hMYDRIVER);
DWORD MYDRIVER_ReadIntrrrupt_Mask (MYDRIVER_HANDLE hMYDRIVER);
void MYDRIVER_WriteIntrrrupt_Mask (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
DWORD MYDRIVER_ReadAux_IO (MYDRIVER_HANDLE hMYDRIVER);
void MYDRIVER_WriteAux_IO (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
DWORD MYDRIVER_ReadINTCSR (MYDRIVER_HANDLE hMYDRIVER);
void MYDRIVER_WriteINTCSR (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls1_Start_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls1_Stop_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls2_Start_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls2_Stop_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls3_Start_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls3_Stop_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls4_Start_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls4_Stop_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls5_Start_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);
void MYDRIVER_WritePuls5_Stop_Soft (MYDRIVER_HANDLE hMYDRIVER, DWORD data);

// handle interrupts
BOOL MYDRIVER_IntIsEnabled (MYDRIVER_HANDLE hMYDRIVER);
BOOL MYDRIVER_IntEnable (MYDRIVER_HANDLE hMYDRIVER, MYDRIVER_INT_HANDLER funcIntHandler, PVOID pUserDat, WORD SET_MY_PRIORITY);
void MYDRIVER_IntDisable (MYDRIVER_HANDLE hMYDRIVER);
// access to PCI configuration registers
void MYDRIVER_WritePCIReg(MYDRIVER_HANDLE hMYDRIVER, DWORD dwReg, DWORD dwData);
DWORD MYDRIVER_ReadPCIReg(MYDRIVER_HANDLE hMYDRIVER, DWORD dwReg);

// this string is set to an error message, if one occurs
extern CHAR MYDRIVER_ErrorString[];


#ifdef __cplusplus
}
#endif

#endif
